<!DOCTYPE HTML>
<html>
<head>
    <title>Minimalistic Recording Test</title>
    <script src="//cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.js" integrity="sha256-yr4fRk/GU1ehYJPAs8P4JlTgu0Hdsp4ZKrx8bDEDC3I=" crossorigin="anonymous"></script>
</head>
<body>
    <h1>Flask-SocketIO Test</h1>
    <p>Async mode is: <b>{{ async_mode }}</b></p>
    <div id="buttons">
      <button class="record">Record</button>
      <button class="stop">Stop</button>
    </div>
    <h2>Receive:</h2>
    <div id="log"></div>
</body>
<script type="text/javascript" charset="utf-8">
  // Use a "/test" namespace.
  // An application can open a connection on multiple namespaces, and
  // Socket.IO will multiplex all those connections on a single
  // physical channel. If you don't care about multiple channels, you
  // can set the namespace to an empty string.
  namespace = '/test';

  // Connect to the Socket.IO server.
  // The connection URL has the following format, relative to the current page:
  //     http[s]://<domain>:<port>[/<namespace>]
  let socket = io(namespace);

  // Event handler for new connections.
  // The callback function is invoked when a connection with the
  // server is established.
  socket.on('connect', function() {
    console.log("connected!")
  });

  // Chrome and Opera will record mono channel Opus (default) and pcm (wav, uncompressed) audio at 48kHz in .webm (Matroska) containers.
  // navigator.mediaDevices.getSupportedConstraints();

  // get the correct mime type (ogg for chrome or webm for firefox)
  let enc = ['ogg', 'webm'];
  let codec = "pcm"; // pcm or opus
  let mime = "";
  let extension = "";
  enc.forEach(e => !extension &&
    (mime = `${e}`) &&
    MediaRecorder.isTypeSupported(`audio/${mime};codecs="${codec}"`) &&
    (extension = e));

  let record = document.querySelector('.record');
  let stop = document.querySelector('.stop');

  if (navigator.mediaDevices.getUserMedia) {
    console.log('getUserMedia supported.');

    {#let constraints = { audio: true };#}
    let constraints = {
      audio: {
        sampleRate: 16000,
        sampleSize: 16,
      }
    };
    let chunks = [];

    let onSuccess = function(stream) {
      let mediaRecorder = new MediaRecorder(stream, {
        // audioBitsPerSecond : 128000,
        // videoBitsPerSecond : 2500000,
        // bitsPerSecond: 12800,
        mimeType: `audio/${mime};codecs="${codec}"` // use the mimeType we have found earlier
      });

      record.onclick = function() {
        mediaRecorder.start(3000); // SPECIFY INTERVAL HERE!
        record.style.background = "red";
        stop.disabled = false;
        record.disabled = true;
      };

      stop.onclick = function() {
        mediaRecorder.stop();
        record.style.background = "";
        record.style.color = "";
        stop.disabled = true;
        record.disabled = false;
      };

      mediaRecorder.onstart = function(e) {
        console.log("media recorder started!");
        socket.emit('recording_started');
      };

      mediaRecorder.onstop = function(e) {
        console.log("media recorder stopped!");
        console.log("data available after MediaRecorder.stop() called.");

        let blob = new Blob(chunks, { 'type' : `audio/${mime};codecs="${codec}"` });
        chunks = [];
        let audioURL = window.URL.createObjectURL(blob);
        console.log("AudioURL: " + audioURL);

        // create audio controls for the user and automatically play the recorded audio
        let au = new Audio(audioURL);
        au.controls = true;
        document.body.appendChild(au);
        au.play();
        // and create an downloadable link from it :
        let a = document.createElement('a');
        a.href = audioURL;
        a.download = 'filename.' + extension;
        a.innerHTML = 'download';
        document.body.appendChild(a);

        socket.emit('recording_stopped', {data: blob, mime: mime, codec: codec});
      };

      mediaRecorder.ondataavailable = function(e) {
        console.log("media recorder data available!");
        chunks.push(e.data);
        console.log(e);

        {#let data = [];#}
        {#data.push(e.data);#}
        {#let blob = new Blob(data, { 'type' : `audio/${mime};codecs="${codec}"` });#}
        socket.emit('data_available', {data: e.data, mime: mime, codec: codec});
      }
    };

    let onError = function(err) {
      console.log('The following error occured: ' + err);
    };

    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);

  } else {
    console.log('getUserMedia not supported on your browser!');
  }
</script>
</html>
